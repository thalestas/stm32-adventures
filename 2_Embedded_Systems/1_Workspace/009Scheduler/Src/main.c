/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* Defines */
#define SYSTICK_CLOCK_SOURCE	8000000U
#define SYSTICK_CFG				1000U

#define NUM_OF_TASKS			2

#define RAM_END					0x20000000
#define PSP_START				RAM_END + (1024 * NUM_OF_TASKS) + SCHE_STACK_SIZE
#define MSP_START				RAM_END + SCHE_STACK_SIZE
#define TASK_STACK_SIZE			1024U
#define SCHE_STACK_SIZE			1024U

#define PSR_INIT				0x1000000U
#define PC_INIT					0x1U
#define LR_INIT					0xFFFFFFFD

/* Global Variable */
static tasks_psp[NUM_OF_TASKS];

/* Prototypes */
void systick_config(const uint32_t systick_freq);
void task_stack_init(const uint8_t num_of_tasks, uint32_t* tasks_addr);
__attribute__((naked)) void sche_stack_init(const uint32_t msp_start);
__attribute__((naked)) void switch_to_psp(const uint32_t psp_start);

void task1(void);
void task2(void);

int main(void)
{
	//Init MSP
	sche_stack_init(MSP_START);

	//Configure and init SysTick
	systick_config(SYSTICK_CFG);

	//Vector to hold tasks address
	uint32_t *ptasks[NUM_OF_TASKS] = {
			(uint32_t*) task1,
			(uint32_t*) task2
	};

	//Init tasks stack
    task_stack_init(NUM_OF_TASKS, ptasks);

    //Switch to PSP stack on Thread Mode
    switch_to_psp(PSP_START);

    task1();

    /* Loop forever */
	for(;;);
}

/* Systick Functions */

void systick_config(const uint32_t systick_freq) {
	//SysTick registers
	volatile uint32_t *const pSCSR = (uint32_t*) 0xE000E010;
	volatile uint32_t *const pSRVR = (uint32_t*) 0xE000E014;

	//Configure Reload Value to reach 1ms
	*pSRVR &= ~(0x00FFFFFF);
	*pSRVR = (SYSTICK_CLOCK_SOURCE / systick_freq) - 1;

	/* Configure SysTick */
	//Uses processor clock
	*pSCSR |= (1 << 2);
	//Enable exception request
	*pSCSR |= (1 << 1);
	//Enable SysTick
	*pSCSR |= (1 << 0);
}

void SysTick_Handler(void) {
	printf("Tucunare!\n");
}

/* Scheduler Functions */
void task_stack_init(const uint8_t num_of_tasks, uint32_t* tasks_addr) {
	volatile uint32_t* psp;

	for(uint8_t i=0; i<num_of_tasks; i++) {
		//First psp position
		psp = PSP_START - (TASK_STACK_SIZE * i);

		//Fill first with PSR
		psp--;
		*psp = PSR_INIT;

		//Fill second with PC
		psp--;
		*psp = tasks_addr[i] + PC_INIT;

		//Fill third with LR
		psp--;
		*psp = LR_INIT;

		//Fill the other R0-R12 with 0
		for(uint8_t j=0; j<13; j++) {
			psp--;
			*psp = 0x0;
		}

		//Save the task psp
		tasks_psp[i] = psp;
	}
}

__attribute__((naked)) void sche_stack_init(const uint32_t msp_start){
	__asm volatile("MSR MSP,%0" : : "r"(msp_start));
	__asm volatile("BX LR");
}

__attribute__((naked)) void switch_to_psp(const uint32_t psp_start) {
	uint32_t ret_control;
	__asm volatile("MSR PSP, %0" : : "r"(psp_start));
	__asm volatile("MRS %0,CONTROL" : "=r"(ret_control));
	ret_control |= (1 << 1);
	__asm volatile("MSR CONTROL, %0" : : "r"(ret_control));
	__asm volatile("BX LR");
}

/* Tasks Implementations */
void task1(void){
	while(1) {
		printf("Jaraquiler!\n");
	}
}
void task2(void){
	while(1) {
		printf("Bodoquiler!\n");
	}
}
